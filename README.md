# Отчет по реализации собственной библиотеки RxJava на Java

---

## 1. Архитектура реализованной системы

Реализованная библиотека построена на классических принципах реактивного программирования и паттерне «Наблюдатель» (Observer pattern). Основные компоненты:

- **Observable<T>** — источник данных, который эмитирует элементы потока и поддерживает подписку подписчиков (`Observer<T>`).  
  - Реализован метод `create()`, позволяющий создавать Observable с кастомной логикой эмиссии.
  - Поддерживает операторы преобразования данных: `map()`, `filter()`, `flatMap()`.
  - Позволяет управлять потоками выполнения через методы `subscribeOn()` и `observeOn()`.

- **Observer<T>** — интерфейс подписчика с методами:  
  - `onNext(T item)` — получение элемента.  
  - `onError(Throwable t)` — обработка ошибок.  
  - `onComplete()` — уведомление о завершении потока.

- **Disposable** — интерфейс для управления жизненным циклом подписки, позволяющий отменять подписку (`dispose()`).

- **Scheduler** — интерфейс для управления потоками выполнения. Позволяет задавать, в каком потоке будет выполняться подписка и обработка событий.

- **Реализации Scheduler:**  
  - `IOThreadScheduler` — использует пул потоков с динамическим размером (CachedThreadPool), подходит для операций ввода-вывода.  
  - `ComputationScheduler` — фиксированный пул потоков (FixedThreadPool), оптимален для CPU-интенсивных задач.  
  - `SingleThreadScheduler` — один поток, подходит для последовательной обработки.

Все компоненты связаны между собой через цепочку вызовов, где Observable эмитирует данные, операторы преобразуют поток, а Observer обрабатывает события.

---

## 2. Принципы работы Schedulers, их различия и области применения

**Scheduler** — это абстракция, управляющая планированием и выполнением задач в определённых потоках.

- **subscribeOn(Scheduler scheduler):**  
  Определяет, в каком потоке будет выполняться процесс подписки и эмиссии данных. Например, если Observable создаёт данные из файлов или сети, `subscribeOn(IOThreadScheduler)` позволяет не блокировать главный поток.

- **observeOn(Scheduler scheduler):**  
  Определяет, в каком потоке будут обрабатываться события (вызовы методов `onNext`, `onError`, `onComplete`). Это важно для обновления UI или последовательной обработки.

### Реализации:

- **IOThreadScheduler (CachedThreadPool):**  
  - Использует динамически расширяемый пул потоков.  
  - Идеален для операций с переменной нагрузкой, часто связанных с вводом-выводом (чтение файлов, запросы в сеть).  
  - Позволяет эффективно использовать ресурсы, создавая новые потоки по необходимости.

- **ComputationScheduler (FixedThreadPool):**  
  - Фиксированное число потоков, обычно равно количеству ядер процессора.  
  - Предназначен для CPU-интенсивных задач, например, вычислений, обработки данных.  
  - Позволяет избежать избыточного создания потоков и конкуренции за CPU.

- **SingleThreadScheduler:**  
  - Выполняет задачи последовательно в одном потоке.  
  - Используется, когда необходима последовательность операций, например, обновление UI или логирование.

---

## 3. Процесс тестирования и основные сценарии

Тестирование реализованной библиотеки проводилось с использованием JUnit 4. Основные направления тестирования:

- **Базовая функциональность Observable и Observer:**  
  Проверка корректного вызова методов `onNext`, `onError`, `onComplete`, корректной работы подписки.

- **Операторы `map`, `filter`, `flatMap`:**  
  Тестирование правильного преобразования, фильтрации и разворачивания вложенных Observable.

- **Обработка ошибок:**  
  Проверка корректной передачи ошибок в `onError` и прекращения потока.

- **Работа Disposable:**  
  Проверка возможности отмены подписки и прекращения эмиссии событий.

- **Работа Scheduler-ов:**  
  В тестах использовались реальные реализации Scheduler-ов с корректным завершением потоков, что позволило проверить асинхронность и переключение потоков.

### Примеры тестовых сценариев:

- Эмиссия нескольких элементов с последующим завершением.
- Преобразование элементов через `map` (например, умножение чисел).
- Фильтрация элементов по условию через `filter`.
- Обработка ошибки, вызванной при эмиссии.
- Отмена подписки после получения нескольких элементов.
- Проверка, что методы `onNext` и `onComplete` вызываются в нужных потоках.

---

## 4. Примеры использования реализованной библиотеки

```java
import myrxjava.;
import myrxjava.schedulers.;

public class Example {
public static void main(String[] args) throws InterruptedException {
    Scheduler ioScheduler = new IOThreadScheduler();
    Scheduler singleScheduler = new SingleThreadScheduler();

    Observable<Integer> observable = Observable.create(emitter -> {
        for (int i = 1; i <= 5; i++) {
            emitter.onNext(i);
        }
        emitter.onComplete();
    });

    Disposable disposable = observable
        .subscribeOn(ioScheduler)         // Подписка в IO потоке
        .observeOn(singleScheduler)       // Обработка в одном потоке
        .filter(i -> i % 2 == 1)          // Фильтрация нечетных чисел
        .map(i -> "Number " + i)          // Преобразование в строку
        .subscribe(new Observer<String>() {
            @Override
            public void onNext(String item) {
                System.out.println("Received: " + item + " Thread: " + Thread.currentThread().getName());
            }

            @Override
            public void onError(Throwable t) {
                System.err.println("Error: " + t.getMessage());
            }

            @Override
            public void onComplete() {
                System.out.println("Done");
            }
        });

    // Ждем завершения для демонстрации
    Thread.sleep(1000);

    disposable.dispose();

    ioScheduler.shutdown();
    singleScheduler.shutdown();
}
}
```

---

## Заключение

Реализованная библиотека соответствует основным принципам реактивного программирования:

- Используется паттерн «Наблюдатель» для подписки и обработки событий.
- Поддерживаются ключевые операторы трансформации потока (`map`, `filter`, `flatMap`).
- Реализована асинхронность и управление потоками через Scheduler.
- Обеспечена обработка ошибок и возможность отмены подписки.
- Проведено комплексное тестирование, подтверждающее корректность работы всех компонентов.

---

